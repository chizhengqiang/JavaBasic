# java基础

* 位（bit）: 一个数字0 或者1 代表 一位

* 字节（Byte）:每逢8位是一个字节，这是数据存储的最小单位.
* 1 byte = 8 bit
* 1ZB = 1024EB = 1024PB = 1024TB = 1024GB = 1024MB = 1025 1kb = 1024 bite

## Java 虚拟机(JVM)

## 数据类型分类

### 基本数据类型

* 整数型	  
  *  `byte`		1个字节
  *  `short`      2个字节
  *   ` int`。    4 个字节 
  *  `long`。   8个字节
* 浮点型。   
  * `float`       4字节
  * ` double`   8字节
* 字符型       `char` 2字节
* 布尔型       `boolean `1字节

_ _ _

| 数据类型 | 字节数 | 范围 |      |
| :------- | ------ | ---- | ---- |
| byte     | 1字节  |      |      |
| short    | 2字节  |      |      |
| int      | 4字节  |      |      |
| long     | 8字节  |      |      |
| float    | 8 字节 |      |      |
| double   | 8字节  |      |      |
| char     | 2字节  |      |      |
| Boolean  | 1字节  |      |      |



### 引用基本类型

* 字符串
* 数组
* 类
* 接口
* `Lambda`

### 注意事项

1. 字符串是引用变量不是基本数据变量
2. 浮点型可能只是一个近似值，并非精确的值
3. 数据范围与字节数不一定相关。列入float类型的数据范围比lōng类型的数据范围更加广泛
4. 浮点型默认是double类型，若使用float类型结尾加f

## 逻辑运算符

* 与（并且）`&&` 全部是true。才是true， 否则是false。
* 或（或者）`||` 至少一个是true，全部是false，才是false
* 非 （取反）`!` 本来是true，变成false，，本来false，变成true
* 与 `&&` 或`||` 具有短路效果。就是左边成立，右边就不需要比较了，从而节省性能。

### 注意事项

* 逻辑运算符只能用于boolean值
* 与、或两种运算符需要左右各有一个boolean值，但是取反只要一个boolean值即可。
* 与、或有多条件可以连续写

## 三元运算符

* 一元运算符：只需要一个数据就进行操作的运算符。

* 二元运算符 : 需要两个数据才能进行操作的运算符

* 三元运算符 ： 需要三个数据才能进行操作的运算符

  `变量名称 = 条件判断 ？ 表达式A ： 表达式B`

## 方法的定义

* 定义方法的格式

```java
public static void 方法名（）{
  方法体
}
```

* 方法名称的命名规则和变量一样，使用小驼峰
* 方法体：也就是大括号当中的包含的任意语句

### 注意事项

1. 方法定义的顺序无所谓
2. 方法的定义不能产生嵌套关系
3. 方法定义好之后，不会执行的，如果想要执行，一定进行方法的**【调用】**
4. 调用方法的格式

```java
方法名称();
```

### 定义方法的完整格式

* 完整格式

```java
修饰符 返回类型	方法名称(参数类型 参数名称,....) {
		方法体
    return  返回值; 
}
```

* 修饰符：现阶段的固定写法`public static`
* 返回值类型：也就是方法最终产生的数据结果是什么类型
* 方法名称：方法的名子。规则和变量一样，小驼峰
* 但属类型：进入方法的数据是什么类型
* 参数名称：进入方法的数据对应的变量名称
* PS: 参数如果多个，使用逗号进行分割
* 方法体：方法需要做的事情，若干行代码
* return：两个作用，第一个是停止当前方法，第二个将后面的返回值还给调用处
* 返回值：也就是方法执行后最终产生的数据结果
* **注意** `return`后面的**返回值**必须和方法前面的`返回值类型`保持对应 

### 方法调用的三种格式

1. 单独调用：方法名称（参数）
2. 打印待用：System.out.println(方法名称(参数))
3. 复制调用：返回类型 参数 = 方法名称（参数）

**注意**  void 只能单独调用，不能进行打印调用，和赋值调用

## 编译器的优化

* 对于byte/short/char三种类型来说，如果右边赋值的数值没有超过范围，那么javac编译器会自动隐含为我们补上一个(byte)/(short)/(char)。
  1. 如果没有超过左侧范围，编译器补上强转。
  2. 如果超过左侧范围，那么编译器直接报错



## 方法的重载（overload）

* 多个方法的名称一样，但参数列表不一样。



## 数组

### 概念

* 是一种容器，可以同时存放多个数据值

### 特点

1. 数组是一种引用类型
2. 数组当中的多个数据，类型必须统一
3. 数组的长度在程序运行期间不可改变

### 初始化

* 在内存当中创建一个数组，并且向其中赋予一些默认值

### 初始化方式

1. 动态初始化（指定长度）
2. 静态初始化（指定内容）

### 格式

* `数据类型[] 数组名称 = new 数组类型[数组长度]`

* `数据类型[] 数组名称 = new 数组类型[]{元素1， 元素2 ,..}`
* `数据类型[] 数组名称 = {元素1， 元素2 ,..}`

```java
int [] arrayA = new int[100]; // 动态初始化

int [] arrayB = new int[] {5, 10, 15}; //静态初始化

int [] arrayC = {元素1, 元素2, ... };	//省略格式
```

### 注意事项

* 虽然静态初始化没有直接告诉长度，但是根据打括号里面的元素具体内容，自动推断出长度
* 静态初始化标准格式可以分为两个步骤
* 动态初始化标准格式可以分为两个步骤
* 静态初始化一旦使用省略格式不能拆为两个步骤

### 使用建议

* 如果不清楚数组当中的具体内容，用动态初始化，否则，已经确定了具体的内容，用静态初始化

```java
int[] array = {10, 20, 30};
System.out.println(array); //[I@61bbe9ba -> 内存地址哈希值
```

### `访问数组元素的格式：数组名称[索引值]`

* 索引值：就是int 数字，代表数组当中元素的编号
* 【注意】索引值从0开始，一直到“数组长度-1”为止

`使用动态初始化数组的时候，其中的元素会自动拥有一个默认值，规则如下`：

* 整数类型：默认值为 0 
* 浮点类型：默认值为 0.0
* 字符类型：默认值为 '\u0000'
* 布尔类型：默认值为 false
* 引用类型：默认值为 null

**【注意事项】**

* 静态初始化其实也有默认值的过程，只不过系统自动马上将默认值替换成了打括号当中的具体数组

## final 关键字

* 当fanal 关键字代表最终的，不可改变的

### 用法

1. 用来修饰一个类
2. 用来修饰一个方法
3. 用来修饰局部变量, 这个局部变量不能进行更改
4. 用来修饰成员变量

**【注意】** 

1. 对于基本类型来说，不可变说的是变量当中的数据不可改变
2. 对于引用数据来说，不可变说的是变量当中地址值不可改变

* 对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样不可改变
  1. 由于成员变量具有默认值，所以使用final之后必须手动赋值不会再给默认值了
  2. 对于final类型的成员变量，要么直接赋值，要么通过构造方法赋值，二者选其一
  3. 必须确保类当中所有重载的构造方法，都最终对final的成员变量进行赋值。

## equals

* 源码

```java
 public boolean equals(Object obj) {
 		return (this == obj);
 }
```

* 参数：
* 基本数据类型：比较的是值
* 引用数据类型：比较的是两个对象的地址值